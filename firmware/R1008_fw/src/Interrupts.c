//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8BB1_Register_Enums.h>
#include "compiler_defs.h"
#include "i2c.h"
#include "global.h"
#include "math.h"
#include "InfoBlock.h"
#include "max31865.h"



char writelen = 0;


//-----------------------------------------------------------------------------
// TIMER0_ISR
//-----------------------------------------------------------------------------
//
// TIMER0 ISR Content goes here. Remember to clear flag bits:
// TCON::TF0 (Timer 0 Overflow Flag)
//
//-----------------------------------------------------------------------------
//SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
//{
//}

//-----------------------------------------------------------------------------
// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN0::SI (SMBus Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
{
    static uint8_t sent_byte_counter;
    static uint8_t rec_byte_counter;

    if (SMB0CN0_ARBLOST == 0)
    {
        switch (SMB0CN0 & 0xF0)          // Decode the SMBus status vector
        {
            // Slave Receiver: Start+Slave Address received
            case SMB_SRADD:
            SMB0CN0_STA = 0;// Clear SMB0CN0_STA bit

            sent_byte_counter = 1;// Reinitialize the data counters
            rec_byte_counter = 1;

            if ((SMB0DAT & 0x01) == READ)// If the transfer is a master READ,
            {
                // Prepare outgoing byte
                SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
                sent_byte_counter++;
            }

            // need to add an acknowledge here????
            // added an ack here
            SMB0CN0_ACK = 1;// send an acknowledge that address and command are received

            break;

            // Slave Receiver: Data received
            case SMB_SRDB:
            if (rec_byte_counter < NUM_BYTES_WR)
            {
                // Store incoming data
                SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
                rec_byte_counter++;
                SMB0CN0_ACK = 1;// SMB0CN0_ACK received data
            }
            else
            {
                // Store incoming data
                SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
                DATA_READY = 1;// Indicate new data fully received
            }
            writelen++;                 // increment global write length counter
            break;

            // Slave Receiver: Stop received while either a Slave Receiver or
            // Slave Transmitter
            case SMB_SRSTO:
            SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
                            // a STOP is detected as a slave

            DATA_READY = 1;// Indicates end of transmission
            break;

            // Slave Transmitter: Data byte transmitted
            case SMB_STDB:
            if (SMB0CN0_ACK == 1)// If Master SMB0CN0_ACK's, send the next byte
            {
                if (sent_byte_counter <= NUM_BYTES_RD)
                {
                    // Prepare next outgoing byte
                    SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
                    sent_byte_counter++;
                }
            }                          // Otherwise, do nothing
            break;

            // Slave Transmitter: Arbitration lost, Stop detected
            //
            // This state will only be entered on a bus error condition.
            // In normal operation, the slave is no longer sending data or has
            // data pending when a STOP is received from the master, so the SMB0CN0_TXMODE
            // bit is cleared and the slave goes to the SRSTO state.
            case SMB_STSTO:
            SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
                            // a STOP is detected as a slave
            break;

                            // Default: all other cases undefined
            default:
            SMB0CF &= ~0x80;// Reset communication
            SMB0CF |= 0x80;
            SMB0CN0_STA = 0;
            SMB0CN0_STO = 0;
            SMB0CN0_ACK = 1;
            break;
        }
    }
    // SMB0CN0_ARBLOST = 1, Abort failed transfer
    else
    {
        SMB0CN0_STA = 0;
        SMB0CN0_STO = 0;
        SMB0CN0_ACK = 1;
    }

    SMB0CN0_SI = 0;                     // Clear SMBus interrupt flag

    // now we look at the contents of the data in the buffer and act accordingly
    if (DATA_READY == 1){

        switch(SMB_DATA_IN[0]){
        case TGT_CMD_RESET_MCU:
            // soft reset MCU
            RSTSRC = 0x12;                  // Initiate software reset with vdd monitor enabled
            break;
        case TGT_CMD_PLID:
            // Return platform ID
            // Prepare buffer with ID string
            SMB_DATA_OUT[0] = PLATFORM;     // Platform ID
            break;
        case TGT_CMD_DVID:
            // Return device ID
            // Prepare buffer with ID string
            SMB_DATA_OUT[0] = DEVID;        // device ID
            break;
        case TGT_CMD_FWID:
            // Return firmware VER
            // Prepare buffer with ID string
            SMB_DATA_OUT[0] = APP_FW_VERSION_LOW;           // firmware version - low byte
            SMB_DATA_OUT[1] = APP_FW_VERSION_HIGH;          // firmware version - high byte
            break;
        case TGT_CMD_TMP:
            // This reads out the temperature value
            SMB_DATA_OUT[0] = temp_internal;
            break;
        case TGT_CMD_BLSTAT:
            SMB_DATA_OUT[0] = 0x00;                         // indicating application mode
            break;
        case TGT_CMD_RTD1TEMP:
            SMB_DATA_OUT[0] = ch1temp.c[0];
            SMB_DATA_OUT[1] = ch1temp.c[1];
            SMB_DATA_OUT[2] = ch1temp.c[2];
            SMB_DATA_OUT[3] = ch1temp.c[3];
            break;
        case TGT_CMD_RTD2TEMP:
            SMB_DATA_OUT[0] = ch2temp.c[0];
            SMB_DATA_OUT[1] = ch2temp.c[1];
            SMB_DATA_OUT[2] = ch2temp.c[2];
            SMB_DATA_OUT[3] = ch2temp.c[3];
            break;
        case TGT_CMD_RTD1RES:
            SMB_DATA_OUT[0] = ch1res.c[0];
            SMB_DATA_OUT[1] = ch1res.c[1];
            SMB_DATA_OUT[2] = ch1res.c[2];
            SMB_DATA_OUT[3] = ch1res.c[3];
            break;
        case TGT_CMD_RTD2RES:
            SMB_DATA_OUT[0] = ch2res.c[0];
            SMB_DATA_OUT[1] = ch2res.c[1];
            SMB_DATA_OUT[2] = ch2res.c[2];
            SMB_DATA_OUT[3] = ch2res.c[3];
            break;
        case TGT_CMD_RTDFAULT:
            // read out fault status
            SMB_DATA_OUT[0] = faultstat;
            faultstat = 0x00;
            break;
        default:
            break;
        }
        writelen = 0;                           // reset writelen counter
        DATA_READY = 0;                         // reset DATA_READY
    }

}

