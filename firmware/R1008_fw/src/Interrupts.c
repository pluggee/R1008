//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8BB1_Register_Enums.h>
#include "compiler_defs.h"
#include "i2c.h"
#include "global.h"
#include "math.h"
#include "InfoBlock.h"
#include <string.h>
#include "max31865.h"

//extern uint32_t ADC_SUM;               // Accumulates the ADC samples
//extern bit CONV_COMPLETE;              // ADC accumulated result ready flag

uint32_t ADC_SUM;                           // Accumulates the ADC samples
//bit CONV_COMPLETE;                        // ADC accumulated result ready flag
char temp_val;
//char TSUM[4];                               // bytes of ADC SUM
//char TADCH, TADCL;                          // bytes for single ADC read

unsigned char Timer2Count;       // counter for multiples of timer2
unsigned short vdd_val; // value of VDD from 12-bit ADC measurement @ 2.4V (0.5X)

char writelen = 0;

// temperature sensor constants
#define DS_SLOPE				0.00285		// slope from datasheet in V/C
#define DS_OFFSET				0.757		// offset from datasheet in V
// LSBSize = 1.65V/(2^12) = 0.000402V

// For 16 samples
//#define SAMPLING_2N             4			// number of samples (power of 2)
//#define SAMPLING_NUMBER         16			// = 2^SAMPLING_2N
//#define TSLOPE                	113			// slope LSB's/C = round(SAMPLING_NUMBER*DS_SLOPE/LSBSize)
//#define TOFFSET                 30067		// Offset in LSB's = round(SAMPLING_NUMBER*DS_OFFSET/LSBSize)

// For a single sample
//#define SAMPLING_2N             0           // number of samples (power of 2)
//#define SAMPLING_NUMBER         1          // = 2^SAMPLING_2N
#define TSLOPE                  7         // slope LSB's/C = round(SAMPLING_NUMBER*DS_SLOPE/LSBSize)
#define TOFFSET                 30067       // Offset in LSB's = round(SAMPLING_NUMBER*DS_OFFSET/LSBSize)
// pin declarations
//SBIT(PWMREF, SFR_P1, 4);            						// Driver mode2 pin

//-----------------------------------------------------------------------------
// TIMER0_ISR
//-----------------------------------------------------------------------------
//
// TIMER0 ISR Content goes here. Remember to clear flag bits:
// TCON::TF0 (Timer 0 Overflow Flag)
//
//-----------------------------------------------------------------------------
//SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
//{
//}

//-----------------------------------------------------------------------------
// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN0::SI (SMBus Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
{
    static uint8_t sent_byte_counter;
    static uint8_t rec_byte_counter;

    if (SMB0CN0_ARBLOST == 0)
    {
        switch (SMB0CN0 & 0xF0)          // Decode the SMBus status vector
        {
            // Slave Receiver: Start+Slave Address received
            case SMB_SRADD:
            SMB0CN0_STA = 0;// Clear SMB0CN0_STA bit

            sent_byte_counter = 1;// Reinitialize the data counters
            rec_byte_counter = 1;

            if ((SMB0DAT & 0x01) == READ)// If the transfer is a master READ,
            {
                // Prepare outgoing byte
                SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
                sent_byte_counter++;
            }

            // need to add an acknowledge here????
            // added an ack here
            SMB0CN0_ACK = 1;// send an acknowledge that address and command are received

            break;

            // Slave Receiver: Data received
            case SMB_SRDB:
            if (rec_byte_counter < NUM_BYTES_WR)
            {
                // Store incoming data
                SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
                rec_byte_counter++;
                SMB0CN0_ACK = 1;// SMB0CN0_ACK received data
            }
            else
            {
                // Store incoming data
                SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
                DATA_READY = 1;// Indicate new data fully received
            }
            writelen++;                 // increment global write length counter
            break;

            // Slave Receiver: Stop received while either a Slave Receiver or
            // Slave Transmitter
            case SMB_SRSTO:
            SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
                            // a STOP is detected as a slave

            DATA_READY = 1;// Indicates end of transmission
            break;

            // Slave Transmitter: Data byte transmitted
            case SMB_STDB:
            if (SMB0CN0_ACK == 1)// If Master SMB0CN0_ACK's, send the next byte
            {
                if (sent_byte_counter <= NUM_BYTES_RD)
                {
                    // Prepare next outgoing byte
                    SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
                    sent_byte_counter++;
                }
            }                          // Otherwise, do nothing
            break;

            // Slave Transmitter: Arbitration lost, Stop detected
            //
            // This state will only be entered on a bus error condition.
            // In normal operation, the slave is no longer sending data or has
            // data pending when a STOP is received from the master, so the SMB0CN0_TXMODE
            // bit is cleared and the slave goes to the SRSTO state.
            case SMB_STSTO:
            SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
                            // a STOP is detected as a slave
            break;

                            // Default: all other cases undefined
            default:
            SMB0CF &= ~0x80;// Reset communication
            SMB0CF |= 0x80;
            SMB0CN0_STA = 0;
            SMB0CN0_STO = 0;
            SMB0CN0_ACK = 1;
            break;
        }
    }
    // SMB0CN0_ARBLOST = 1, Abort failed transfer
    else
    {
        SMB0CN0_STA = 0;
        SMB0CN0_STO = 0;
        SMB0CN0_ACK = 1;
    }

    SMB0CN0_SI = 0;                     // Clear SMBus interrupt flag

    // now we look at the contents of the data in the buffer and act accordingly
    if (DATA_READY == 1){

        switch(SMB_DATA_IN[0]){
        case TGT_CMD_RESET_MCU:
            // soft reset MCU
            RSTSRC = 0x12;                  // Initiate software reset with vdd monitor enabled
            break;
        case TGT_CMD_PLID:
            // Return platform ID
            // Prepare buffer with ID string
            SMB_DATA_OUT[0] = PLATFORM;     // Platform ID
            break;
        case TGT_CMD_DVID:
            // Return device ID
            // Prepare buffer with ID string
            SMB_DATA_OUT[0] = DEVID;        // device ID
            break;
        case TGT_CMD_FWID:
            // Return firmware VER
            // Prepare buffer with ID string
            SMB_DATA_OUT[0] = APP_FW_VERSION_LOW;           // firmware version - low byte
            SMB_DATA_OUT[1] = APP_FW_VERSION_HIGH;          // firmware version - high byte
            break;
        case TGT_CMD_TMP:
            // This reads out the temperature value
            SMB_DATA_OUT[0] = temp_val;
            break;
        case TGT_CMD_BLSTAT:
            SMB_DATA_OUT[0] = 0x00;                         // indicating application mode
            break;
        case TGT_CMD_RTD1TEMP:
            memcpy(SMB_DATA_OUT, &ch1temp, sizeof(float));
            break;
        case TGT_CMD_RTD2TEMP:
            memcpy(SMB_DATA_OUT, &ch2temp, sizeof(float));
            break;
#ifdef DEBUGFW
        case 0x34:
            SMB_DATA_OUT[0] = rtdlsb;
            SMB_DATA_OUT[1] = rtdmsb;
            break;
        case 0x36:
            SMB_DATA_OUT[0] = faultstat;
            break;
        case 0x37:
            SMB_DATA_OUT[0] = r_hftlsb;
            SMB_DATA_OUT[1] = r_hftmsb;
            SMB_DATA_OUT[2] = r_lftlsb;
            SMB_DATA_OUT[3] = r_lftmsb;
            break;
#endif
        default:
            break;
        }
        writelen = 0;                           // reset writelen counter
        DATA_READY = 0;                         // reset DATA_READY
    }

}

